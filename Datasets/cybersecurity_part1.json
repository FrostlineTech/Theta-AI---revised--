[
  {
    "question": "What is a zero-day exploit?",
    "answer": "A zero-day exploit is a cyber attack that targets a previously unknown vulnerability in software or hardware - one that hasn't yet been patched or even discovered by the developers or vendors. The term \"zero-day\" refers to the fact that developers have had zero days to address and patch the vulnerability since it became known. These exploits are particularly dangerous for several reasons: 1) No patches or fixes exist at the time of exploitation; 2) Signature-based security solutions can't detect them since no signatures exist for unknown vulnerabilities; 3) They're often sold on underground markets for significant sums or used by sophisticated threat actors like nation-states; 4) They provide attackers with a critical time advantage until the vulnerability is discovered and patched. The lifecycle typically involves: discovery of the vulnerability (either by security researchers or malicious actors), development of exploit code, deployment of the attack, eventual discovery and disclosure, and finally patch development and distribution. Notable examples include Stuxnet (targeting Iranian nuclear facilities), the Microsoft Exchange Server vulnerabilities exploited in 2021, and various attacks against web browsers and operating systems. Organizations can reduce their risk through defense-in-depth strategies including behavior-based detection, regular updates, network segmentation, principle of least privilege, and advanced endpoint protection solutions that can detect unusual system behavior even when the specific exploit isn't known."
  },
  {
    "question": "What is the difference between symmetric and asymmetric encryption?",
    "answer": "Symmetric and asymmetric encryption are two fundamental cryptographic approaches that differ in key usage, performance, security properties, and typical applications. Symmetric encryption uses a single shared key for both encryption and decryption. This means anyone who can encrypt data can also decrypt it, and vice versa. Common algorithms include AES (Advanced Encryption Standard), DES (Data Encryption Standard, now deprecated), and ChaCha20. Symmetric encryption is fast and efficient, suitable for encrypting large volumes of data, but faces the key distribution problem - securely sharing the key between parties without it being intercepted. Asymmetric encryption (also called public key cryptography) uses mathematically related key pairs - a public key for encryption and a private key for decryption. Data encrypted with the public key can only be decrypted with the corresponding private key. Common algorithms include RSA, ECC (Elliptic Curve Cryptography), and DSA. This approach solves the key distribution problem since public keys can be freely shared, but it's significantly slower than symmetric encryption and more computationally intensive. In practice, modern cryptographic systems often use a hybrid approach: asymmetric encryption to securely exchange a temporary symmetric key (called a session key), which is then used for bulk data encryption. For example, in TLS (used for HTTPS), RSA or ECDHE is used for key exchange, after which AES encrypts the actual data transfer. Asymmetric encryption also enables digital signatures (using the private key to sign and the public key to verify) which provide authentication and non-repudiation capabilities that symmetric encryption cannot."
  },
  {
    "question": "What is a man-in-the-middle attack and how can it be prevented?",
    "answer": "A man-in-the-middle (MITM) attack occurs when an attacker secretly intercepts and potentially alters communications between two parties who believe they are directly communicating with each other. The attacker positions themselves between the victims, establishing independent connections with both sides and relaying messages between them. This allows the attacker to eavesdrop on sensitive information and potentially modify the data in transit. Common MITM attack scenarios include: 1) Network-based attacks where attackers connect to unsecured WiFi networks or create rogue access points; 2) ARP spoofing/poisoning to redirect traffic on local networks; 3) DNS spoofing to redirect users to malicious websites; 4) Session hijacking by stealing authentication cookies; 5) SSL stripping to downgrade HTTPS connections to unencrypted HTTP. Prevention measures operate at multiple levels: 1) Encryption - Using strong, end-to-end encryption protocols like TLS/SSL that authenticate both ends of the connection. Always implement HTTPS for web applications with HTTP Strict Transport Security (HSTS) to prevent SSL stripping. 2) Authentication - Implementing mutual authentication where both parties verify each other's identity, such as with certificate-based authentication or modern protocols like OAuth 2.0 with PKCE. 3) Certificate validation - Properly validating TLS certificates by checking if they're issued by trusted Certificate Authorities, not expired, and match the expected domain. Certificate pinning further restricts which certificates are trusted. 4) Public key infrastructure (PKI) - Using a robust PKI system with certificate transparency and proper certificate lifecycle management. 5) Network security - Using Virtual Private Networks (VPNs), especially on public WiFi, implementing DNS Security Extensions (DNSSEC), and securing network infrastructure with proper access controls and monitoring. 6) User education - Training users to recognize security warnings, avoid unsecured WiFi, and verify website security indicators. For highly sensitive communications, additional measures like out-of-band verification of cryptographic keys may be implemented to prevent sophisticated MITM attacks."
  },
  {
    "question": "What is a buffer overflow vulnerability?",
    "answer": "A buffer overflow vulnerability occurs when a program writes data beyond the allocated memory buffer boundaries, overwriting adjacent memory locations. This happens because many programming languages (particularly C and C++) don't automatically check boundary conditions, allowing programs to write more data into a buffer than it was designed to hold. The consequences can be severe, potentially allowing attackers to: 1) Crash the application, causing denial of service; 2) Corrupt data in adjacent memory; 3) Execute arbitrary code by overwriting function pointers or return addresses on the stack; 4) Escalate privileges if the vulnerable program runs with higher permissions. Buffer overflows come in several types: Stack-based overflows target buffers allocated on the program stack, often overwriting the return address to hijack program execution; Heap-based overflows occur in dynamically allocated memory and typically overwrite heap management structures; Integer overflows/underflows can lead to buffer overflows when calculations determining buffer sizes wrap around. Prevention strategies include: 1) Using memory-safe languages like Rust, Go, Java, or Python that perform automatic bounds checking; 2) Implementing proper input validation to ensure data fits within allocated buffers; 3) Using safer library functions that limit writing (strncpy instead of strcpy in C); 4) Enabling compiler protections like stack canaries (which detect stack corruption), Address Space Layout Randomization (ASLR), and Data Execution Prevention (DEP); 5) Following secure coding practices with regular code reviews and static analysis tools; 6) Applying the principle of least privilege so that even if code execution occurs, the attacker has limited access. Despite being one of the oldest vulnerability types, buffer overflows remain common in systems programming and embedded devices. The Morris Worm of 1988, one of the first computer worms, exploited a buffer overflow, and they continue to appear in vulnerability databases today, highlighting the persistent challenge they present to software security."
  },
  {
    "question": "What is cross-site scripting (XSS) and how can it be prevented?",
    "answer": "Cross-Site Scripting (XSS) is a web security vulnerability that allows attackers to inject malicious client-side scripts (typically JavaScript) into web pages viewed by other users. When these pages load in victims' browsers, the injected scripts execute, giving attackers access to cookies, session tokens, and other sensitive information retained by the browser. XSS attacks come in three main types: 1) Reflected XSS - malicious script is embedded in a URL and activated when a user clicks a malicious link, with the script being reflected off the web server in the response; 2) Stored XSS - the malicious script is permanently stored on target servers (in databases, message forums, comment fields) and executes when users visit the affected page; 3) DOM-based XSS - vulnerabilities exist in client-side code rather than server-side, with attacks occurring entirely in the browser when JavaScript dynamically includes attacker-controllable data in a page. The consequences can be severe: attackers can steal session cookies enabling account hijacking, capture credentials through fake login forms, redirect users to malicious sites, or even take control of the user's browser through BeEF (Browser Exploitation Framework). Prevention requires multiple defensive layers: 1) Input validation - validate and sanitize all user inputs on the server side, rejecting potentially malicious content; 2) Output encoding - context-appropriate encoding of user-generated content when displayed (HTML entity encoding, JavaScript escaping, CSS escaping, URL encoding); 3) Content Security Policy (CSP) - HTTP headers that restrict which scripts can execute and from what sources; 4) Modern framework protections - frameworks like React, Angular, and Vue automatically escape content by default; 5) HttpOnly and Secure cookie flags to prevent JavaScript access to sensitive cookies; 6) X-XSS-Protection header to enable built-in browser XSS filters; 7) Regular security testing including both automated scanning and manual penetration testing specifically for XSS. Proper implementation of these measures significantly reduces XSS risk, though complete protection requires ongoing vigilance as web applications evolve."
  },
  {
    "question": "What is a SQL injection attack and how can it be prevented?",
    "answer": "SQL injection is a code injection technique where an attacker inserts malicious SQL statements into entry fields in a web application, which are then executed by the underlying database. This vulnerability occurs when user input is incorrectly filtered or sanitized before being incorporated into SQL queries. A successful SQL injection can allow attackers to: 1) Access unauthorized data, including sensitive personal information, credentials, or intellectual property; 2) Modify database data (insert, update, delete records); 3) Execute administrative operations on the database (shutdown, upload files); 4) Recover the content of a given file on the DBMS file system; 5) In some cases, issue commands to the operating system. Common examples include adding ' OR '1'='1 to input fields, which can transform queries like SELECT * FROM users WHERE username='input' AND password='input' into SELECT * FROM users WHERE username='' OR '1'='1' -- ' AND password='', effectively bypassing authentication by making the WHERE clause always true. Prevention strategies include: 1) Parameterized queries (prepared statements) - separating SQL code from data by creating the query structure first and then passing user input as parameters, preventing it from being interpreted as SQL commands; 2) Stored procedures - precompiled SQL statements that accept only parameters, not executable code; 3) Input validation - checking that user input matches expected formats using data type, length, and format constraints; 4) Escaping special characters in user inputs according to the specific database's syntax; 5) Implementing least privilege principles for database accounts used by applications; 6) Using ORM (Object-Relational Mapping) frameworks that handle parameterization automatically; 7) Web Application Firewalls (WAF) that can detect and block SQL injection attempts; 8) Regular security testing with specialized tools and manual penetration testing. While parameterized queries offer the most robust protection and should be the primary defense, a layered security approach combining multiple techniques provides the best protection against these attacks, which remain among the most common and dangerous web application vulnerabilities."
  },
  {
    "question": "What is a DDoS attack and how can organizations defend against it?",
    "answer": "A Distributed Denial of Service (DDoS) attack is a malicious attempt to disrupt the normal traffic of a targeted server, service, or network by overwhelming it with a flood of internet traffic from multiple sources. Unlike a simple DoS attack originating from a single source, DDoS attacks leverage multiple compromised systems (often thousands of devices infected with malware forming a \"botnet\") to generate the attack traffic, making them much more difficult to mitigate. Common DDoS attack types include: 1) Volume-based attacks like UDP floods, ICMP floods, and amplification attacks that consume bandwidth; 2) Protocol attacks like SYN floods that exhaust server resources by exploiting TCP/IP protocol weaknesses; 3) Application layer attacks (HTTP floods, Slowloris) that target specific applications with seemingly legitimate requests. The impacts can be severe: service unavailability, lost revenue, reputational damage, and significant remediation costs. Organizations can defend against DDoS attacks through a multi-layered approach: 1) Increase network bandwidth and server capacity to absorb smaller attacks (\"overprovision\"); 2) Implement traffic analysis tools to establish normal traffic baselines and identify anomalous patterns; 3) Deploy specialized DDoS protection services or appliances that can detect and filter malicious traffic; 4) Use Content Delivery Networks (CDNs) to distribute traffic across multiple servers and locations; 5) Configure network devices with rate limiting, traffic shaping, and access control lists; 6) Implement anycast network addressing to distribute attack traffic across multiple points of presence; 7) Deploy Web Application Firewalls (WAFs) for application-layer protection; 8) Develop an incident response plan specifically for DDoS scenarios, including communication protocols and technical responses; 9) Consider cloud-based DDoS protection services that can absorb massive attack traffic before it reaches your infrastructure. For critical services, a combination of on-premises defenses for immediate protection and cloud-based scrubbing services for larger attacks typically provides the most comprehensive defense. As attack techniques continue to evolve, regular testing and updating of defense mechanisms is essential to maintain effective protection."
  },
  {
    "question": "What is two-factor authentication (2FA) and why is it important?",
    "answer": "Two-factor authentication (2FA) is a security mechanism that requires users to provide two different authentication factors to verify their identity, significantly enhancing security compared to password-only authentication. These factors fall into three categories: something you know (passwords, PINs), something you have (physical tokens, mobile devices), and something you are (biometrics like fingerprints or facial recognition). Common 2FA implementations include: SMS or voice call verification codes, authenticator apps generating time-based one-time passwords (TOTPs), hardware security keys (like YubiKeys using standards such as FIDO U2F or WebAuthn), push notifications to trusted devices, or biometric verification. 2FA is important for several reasons: 1) Password vulnerabilities - It addresses the inherent weaknesses in password-only systems, where credentials can be stolen through phishing, data breaches, keyloggers, or brute force attacks. Even if an attacker obtains the password, they still need the second factor to gain access. 2) Defense in depth - It implements the security principle of layered protection, requiring attackers to compromise multiple, different types of authentication mechanisms. 3) Breach impact reduction - Organizations implementing 2FA have experienced up to 99% reduction in account compromise rates according to studies by Google and Microsoft. 4) Regulatory compliance - Many regulations and standards now require or strongly recommend multi-factor authentication, including PCI DSS, HIPAA, NIST guidelines, and GDPR (indirectly through security requirements). 5) Protection against common attack vectors - 2FA effectively mitigates risks from credential stuffing, brute force attacks, and most phishing attempts. However, 2FA is not immune to all attacks - sophisticated phishing can sometimes capture both factors, SIM swapping can compromise SMS-based verification, and social engineering might bypass certain implementations. For this reason, stronger forms like hardware security keys are preferred over SMS when possible. Despite these potential weaknesses, properly implemented 2FA dramatically increases security posture by requiring attackers to execute much more complex, targeted attacks rather than automated or broad-based credential attacks, making it a cornerstone security practice for both organizations and individuals."
  }
]
