[
  {
    "question": "What are design patterns in software development?",
    "answer": "Design patterns in software development are reusable solutions to common problems that arise during software design. They represent best practices evolved over time by experienced developers. Design patterns are not complete code solutions, but rather templates for how to solve a particular problem that can be adapted to different situations. They are categorized into three main types: 1) Creational patterns (like Singleton, Factory Method, and Builder) which deal with object creation mechanisms, 2) Structural patterns (like Adapter, Decorator, and Composite) which focus on object composition and relationships, and 3) Behavioral patterns (like Observer, Strategy, and Command) which characterize communication between objects. Using design patterns helps create more maintainable, flexible, and understandable code by leveraging established, well-tested solutions."
  },
  {
    "question": "What is dependency injection?",
    "answer": "Dependency Injection (DI) is a software design pattern that implements Inversion of Control for resolving dependencies. In this pattern, the objects are given their dependencies at creation time by an external entity rather than creating them internally. There are three common types of dependency injection: constructor injection (dependencies provided through a class constructor), setter injection (dependencies provided through setter methods), and interface injection (dependencies provided through interfaces). DI promotes loose coupling between components, making code more modular, testable, and maintainable. It allows for easier unit testing through mocking of dependencies and facilitates changing implementations without modifying the dependent code. Many modern frameworks like Spring (Java), ASP.NET Core (C#), and Angular (JavaScript) have built-in support for dependency injection."
  },
  {
    "question": "What is functional programming?",
    "answer": "Functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. It emphasizes the application of functions without modifying data outside the function's scope. Key concepts include: 1) Pure functions - functions that always produce the same output for the same input and have no side effects, 2) Immutability - once data is created, it cannot be changed, 3) First-class and higher-order functions - functions can be assigned to variables, passed as arguments, and returned from other functions, 4) Recursion - used for iterative processes instead of loops, 5) Referential transparency - expressions can be replaced with their values without changing program behavior. Languages that support functional programming include Haskell, Clojure, Scala, and F#, while JavaScript, Python, and other mainstream languages incorporate many functional programming features. This paradigm can lead to more predictable, testable, and concurrent code."
  },
  {
    "question": "What is the MVC architecture pattern?",
    "answer": "MVC (Model-View-Controller) is an architectural design pattern that separates an application into three interconnected components to separate internal representations of information from the ways information is presented to and accepted from the user. The Model component represents the application's data and business logic, handling data storage, validation, and processing rules. The View component is responsible for the user interface elements and presentation of data to the user. The Controller component acts as an intermediary between Model and View, processing user inputs, manipulating data using the Model, and selecting which View to render. This separation of concerns makes applications more maintainable, reusable, and scalable by allowing developers to work on different components independently. MVC is widely used in web frameworks like Ruby on Rails, ASP.NET MVC, Django, and many others, although variations like MVP (Model-View-Presenter) and MVVM (Model-View-ViewModel) have evolved to address specific needs."
  },
  {
    "question": "What is REST API?",
    "answer": "REST (Representational State Transfer) API is an architectural style for designing networked applications. RESTful APIs use HTTP requests to perform CRUD operations (Create, Read, Update, Delete) on resources, which are represented as URLs. Key principles include: 1) Statelessness - each request from client to server contains all information needed to understand and complete the request, 2) Client-server architecture - separating user interface concerns from data storage concerns, 3) Cacheability - responses must define themselves as cacheable or non-cacheable, 4) Layered system - client cannot ordinarily tell if it's connected directly to the end server or intermediary, 5) Uniform interface - resources are identified in requests, resources are manipulated through representations, messages are self-descriptive, and hypermedia as the engine of application state. REST APIs typically use HTTP methods (GET, POST, PUT, DELETE) for operations, return data in formats like JSON or XML, use standard HTTP status codes, and are designed around resources rather than actions. They're widely used for web services due to their simplicity, scalability, and performance."
  },
  {
    "question": "What is the difference between compiled and interpreted languages?",
    "answer": "Compiled languages convert source code directly into machine code before execution, creating an executable file specific to a target platform. This process happens only once during development, allowing for faster execution times and earlier error detection. Examples include C, C++, Rust, and Go. In contrast, interpreted languages execute code line-by-line at runtime through an interpreter without prior compilation to machine code. This enables greater platform independence and dynamic features but typically results in slower execution. Examples include Python, JavaScript, and Ruby. Some languages use a hybrid approach: Java and C# compile to intermediate bytecode which is then interpreted or just-in-time compiled by a virtual machine, combining some advantages of both approaches. The key trade-offs between compiled and interpreted languages involve execution speed, development flexibility, platform dependence, and error detection timing."
  },
  {
    "question": "What is CI/CD in software development?",
    "answer": "CI/CD (Continuous Integration/Continuous Deployment or Delivery) is a set of practices in software development that automates the process of integrating code changes and delivering applications. Continuous Integration involves automatically testing and building code every time a team member commits changes to version control. This practice helps detect integration issues early, improves code quality through automated testing, and provides immediate feedback to developers. Continuous Delivery extends CI by automatically deploying all code changes to a testing or staging environment after the build stage. Continuous Deployment goes further by automatically releasing those changes to production after passing all tests. The CI/CD pipeline typically includes stages like source control, build automation, test automation, deployment automation, and monitoring. Popular tools for implementing CI/CD include Jenkins, GitHub Actions, GitLab CI/CD, CircleCI, and Travis CI. These practices help teams deliver updates more frequently and reliably by reducing manual processes and encouraging smaller, incremental changes."
  },
  {
    "question": "What is the difference between SQL and NoSQL databases?",
    "answer": "SQL (Structured Query Language) and NoSQL (Not Only SQL) represent two different database paradigms. SQL databases are relational databases that organize data into structured tables with predefined schemas, using SQL for defining and manipulating data. They excel at complex queries, relationships between data entities, and transactions requiring ACID properties (Atomicity, Consistency, Isolation, Durability). Examples include MySQL, PostgreSQL, and Oracle. NoSQL databases, by contrast, are non-relational databases designed for specific data models with flexible schemas. They prioritize scalability and performance over consistency, following the BASE principles (Basically Available, Soft state, Eventually consistent). NoSQL databases come in several types: document stores (MongoDB, Couchbase), key-value stores (Redis, DynamoDB), wide-column stores (Cassandra, HBase), and graph databases (Neo4j, Amazon Neptune). SQL databases are typically better for complex queries and transactions, while NoSQL databases excel at handling large volumes of unstructured data, rapid development cycles, and horizontal scalability across distributed systems."
  },
  {
    "question": "What is code refactoring?",
    "answer": "Code refactoring is the process of restructuring existing computer code without changing its external behavior. The goal is to improve the code's non-functional attributes such as readability, complexity, maintainability, and extensibility. Refactoring should be distinguished from rewriting code or fixing bugs. Common refactoring techniques include extracting methods or classes to reduce duplication, simplifying conditional expressions, renaming variables for clarity, replacing hard-coded values with constants, and reorganizing class hierarchies. Benefits include reduced technical debt, easier maintenance, better code understanding for new team members, and more efficient future development. Best practices include performing refactoring in small, incremental steps, maintaining a comprehensive test suite to verify that functionality remains unchanged, and scheduling regular refactoring sessions as part of the development process. Tools like IDEs often provide automated refactoring capabilities to reduce errors and speed up the process."
  },
  {
    "question": "What are microservices?",
    "answer": "Microservices architecture is an approach to software development where an application is structured as a collection of small, loosely coupled services that can be developed, deployed, and scaled independently. Each microservice is focused on a single business capability, runs in its own process, communicates through well-defined APIs (typically HTTP/REST), and can be written in different programming languages. This contrasts with monolithic architecture where all functionality exists in a single codebase. Key characteristics include: decentralized data management with each service managing its own database, independent deployment allowing teams to update services without affecting others, failure isolation so that issues in one service don't cascade throughout the system, and team autonomy enabling smaller teams to own specific services. While microservices offer benefits like scalability, technology diversity, and resilience, they also introduce challenges such as increased operational complexity, distributed system problems, and service coordination. Organizations like Netflix, Amazon, and Spotify have successfully implemented microservices at scale."
  }
]
